!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.15 (master) - 15 Apr 2020 11:54
!
MODULE MODELS_DIFF
  IMPLICIT NONE

CONTAINS
! split data
  SUBROUTINE GETDATAACTIVITY_NRTL(modelname, npardata, pardata, a, alpha&
&   , r)
    IMPLICIT NONE
    CHARACTER(len=20), INTENT(IN) :: modelname
    INTEGER, INTENT(IN) :: npardata
    DOUBLE PRECISION, INTENT(IN) :: pardata(npardata)
    DOUBLE PRECISION, DIMENSION(3, 3), INTENT(OUT) :: a, alpha
    DOUBLE PRECISION, INTENT(OUT) :: r
!! Matrix A of binary interaction
    a(1, :) = pardata(1:3)
    a(2, :) = pardata(4:6)
    a(3, :) = pardata(7:9)
!! Symetric matrix Alpha
    alpha(1, :) = pardata(10:12)
    alpha(2, :) = pardata(13:15)
    alpha(3, :) = pardata(16:18)
!! The constant R
    r = pardata(19)
  END SUBROUTINE GETDATAACTIVITY_NRTL

  SUBROUTINE GETDATAACTIVITY_UNIQUAC(modelname, npardata, pardata, a, rp&
&   , q, qp, z, r)
    IMPLICIT NONE
    CHARACTER(len=20), INTENT(IN) :: modelname
    INTEGER, INTENT(IN) :: npardata
    DOUBLE PRECISION, INTENT(IN) :: pardata(npardata)
    DOUBLE PRECISION, DIMENSION(3, 3), INTENT(OUT) :: a
    DOUBLE PRECISION, DIMENSION(3), INTENT(OUT) :: rp, q, qp
    DOUBLE PRECISION, INTENT(OUT) :: z, r
!! Matrix A of binary interaction
    a(1, :) = pardata(1:3)
    a(2, :) = pardata(4:6)
    a(3, :) = pardata(7:9)
!! Coefficient r, q, Qp
    rp = pardata(10:12)
    q = pardata(13:15)
    qp = pardata(16:18)
!! The constant z
    z = pardata(19)
!! The constant R
    r = pardata(20)
  END SUBROUTINE GETDATAACTIVITY_UNIQUAC

  SUBROUTINE GETDATAPRESSURE_ANTOINE(modelname, npardata, pardata, &
&   antoinea, antoineb, antoinec)
    IMPLICIT NONE
    CHARACTER(len=20), INTENT(IN) :: modelname
    INTEGER, INTENT(IN) :: npardata
    DOUBLE PRECISION, INTENT(IN) :: pardata(npardata)
    DOUBLE PRECISION, DIMENSION(3), INTENT(OUT) :: antoinea, antoineb, &
&   antoinec
!! Antoine's Equation constants
    antoinea = pardata(1:3)
    antoineb = pardata(4:6)
    antoinec = pardata(7:9)
  END SUBROUTINE GETDATAPRESSURE_ANTOINE

  SUBROUTINE GETDATAPRESSURE_DIPPR(modelname, npardata, pardata, dippra&
&   , dipprb, dipprc, dipprd, dippre, P0)
    IMPLICIT NONE
    CHARACTER(len=20), INTENT(IN) :: modelname
    INTEGER, INTENT(IN) :: npardata
    DOUBLE PRECISION, INTENT(IN) :: pardata(npardata)
    DOUBLE PRECISION, DIMENSION(3), INTENT(OUT) :: dippra, dipprb, &
&   dipprc, dipprd, dippre
    INTEGER :: P0
!! Dippr's Equation constants
    dippra = pardata(1:3)
    dipprb = pardata(4:6)
    dipprc = pardata(7:9)
    dipprd = pardata(10:12)
    dippre = pardata(13:15)
    P0 = pardata(16)
  END SUBROUTINE GETDATAPRESSURE_DIPPR

!  Differentiation of getpressure in forward (tangent) mode:
!   variations   of useful results: pression
!   with respect to varying inputs: temperature
  SUBROUTINE GETPRESSURE_D(temperature, temperatured, modelname, &
&   modelpars_dim, modelpars, pression, pressiond)
    IMPLICIT NONE
    DOUBLE PRECISION, INTENT(IN) :: temperature
    DOUBLE PRECISION, INTENT(IN) :: temperatured
    CHARACTER(len=20), INTENT(IN) :: modelname
    INTEGER, INTENT(IN) :: modelpars_dim
    DOUBLE PRECISION, INTENT(IN) :: modelpars(modelpars_dim)
    DOUBLE PRECISION, INTENT(OUT) :: pression(3)
    DOUBLE PRECISION, INTENT(OUT) :: pressiond(3)
! on calcule p en fonction du modèle
! attention, la taille du vecteur de paramètres modelpars dépend de modelname
! modelname = 'antoine', 'dippr'
! Local variables
    DOUBLE PRECISION, DIMENSION(3) :: antoinea, antoineb, antoinec
    DOUBLE PRECISION, DIMENSION(3) :: dippra, dipprb, dipprc, dipprd, &
&   dippre
    INTEGER :: n, P0
    DOUBLE PRECISION :: t
    DOUBLE PRECISION :: td
!! Loop indice
    INTEGER :: i
    INTRINSIC TRIM
    INTRINSIC EXP
    DOUBLE PRECISION :: pwy1
    DOUBLE PRECISION :: pwy1d
    DOUBLE PRECISION :: pwr1
    DOUBLE PRECISION :: pwr1d
    DOUBLE PRECISION :: pwr2
    DOUBLE PRECISION :: pwr2d
    DOUBLE PRECISION :: arg1
    DOUBLE PRECISION :: arg1d
    DOUBLE PRECISION :: temp
    td = temperatured
    t = temperature
    n = 3
    SELECT CASE  (TRIM(modelname))
    CASE ('ANTOINE', 'antoine')
!! Antoine model
! get data
      CALL GETDATAPRESSURE_ANTOINE(modelname, modelpars_dim, modelpars, &
&                            antoinea, antoineb, antoinec)
      pressiond = 0.D0
!! Calcul des pressions partielles Pi en utilisant l'equation d'antoine
      DO i=1,n,1
        temp = antoineb(i)/(antoinec(i)+t)
        pwy1d = temp*td/(antoinec(i)+t)
        pwy1 = antoinea(i) - temp
        temp = 10d0**pwy1
        pressiond(i) = temp*LOG(10d0)*pwy1d
        pression(i) = temp
      END DO
    CASE ('DIPPR', 'dippr')
! get Data
      CALL GETDATAPRESSURE_DIPPR(modelname, modelpars_dim, modelpars, &
&                          dippra, dipprb, dipprc, dipprd, dippre, P0)
      pressiond = 0.D0
!! Calcul des pressions partielles Pi en utilisant l'equation DIPPR
      DO i=1,n,1
        IF (t .LE. 0.0 .AND. (dipprc(i) .EQ. 0.0 .OR. dipprc(i) .NE. INT&
&           (dipprc(i)))) THEN
          pwr1d = 0.D0
        ELSE
          pwr1d = dipprc(i)*t**(dipprc(i)-1)*td
        END IF
        pwr1 = t**dipprc(i)
        IF (t .LE. 0.0 .AND. (dippre(i) .EQ. 0.0 .OR. dippre(i) .NE. INT&
&           (dippre(i)))) THEN
          pwr2d = 0.D0
        ELSE
          pwr2d = dippre(i)*t**(dippre(i)-1)*td
        END IF
        pwr2 = t**dippre(i)
        temp = dipprb(i)/t
        arg1d = dipprd(i)*pwr2d - temp*td/t
        arg1 = dippra(i) + temp + dipprd(i)*pwr2
        temp = EXP(arg1)
        pressiond(i) = temp*pwr1d + pwr1*EXP(arg1)*arg1d
        pression(i) = pwr1*temp
      END DO
    CASE DEFAULT
      WRITE(*, *) 'Wrong choice of model.'
      STOP
    END SELECT
  END SUBROUTINE GETPRESSURE_D

  SUBROUTINE GETPRESSURE(temperature, modelname, modelpars_dim, &
&   modelpars, pression)
    IMPLICIT NONE
    DOUBLE PRECISION, INTENT(IN) :: temperature
    CHARACTER(len=20), INTENT(IN) :: modelname
    INTEGER, INTENT(IN) :: modelpars_dim
    DOUBLE PRECISION, INTENT(IN) :: modelpars(modelpars_dim)
    DOUBLE PRECISION, INTENT(OUT) :: pression(3)
! on calcule p en fonction du modèle
! attention, la taille du vecteur de paramètres modelpars dépend de modelname
! modelname = 'antoine', 'dippr'
! Local variables
    DOUBLE PRECISION, DIMENSION(3) :: antoinea, antoineb, antoinec
    DOUBLE PRECISION, DIMENSION(3) :: dippra, dipprb, dipprc, dipprd, &
&   dippre
    INTEGER :: n, P0
    DOUBLE PRECISION :: t
!! Loop indice
    INTEGER :: i
    INTRINSIC TRIM
    INTRINSIC EXP
    DOUBLE PRECISION :: pwy1
    DOUBLE PRECISION :: pwr1
    DOUBLE PRECISION :: pwr2
    DOUBLE PRECISION :: arg1
    t = temperature
    n = 3
    SELECT CASE  (TRIM(modelname))
    CASE ('ANTOINE', 'antoine')
!! Antoine model
! get data
      CALL GETDATAPRESSURE_ANTOINE(modelname, modelpars_dim, modelpars, &
&                            antoinea, antoineb, antoinec)
!! Calcul des pressions partielles Pi en utilisant l'equation d'antoine
      DO i=1,n,1
        pwy1 = antoinea(i) - antoineb(i)/(t+antoinec(i))
        pression(i) = 10d0**pwy1
      END DO
    CASE ('DIPPR', 'dippr')
! get Data
      CALL GETDATAPRESSURE_DIPPR(modelname, modelpars_dim, modelpars, &
&                          dippra, dipprb, dipprc, dipprd, dippre, P0)
!! Calcul des pressions partielles Pi en utilisant l'equation DIPPR
      DO i=1,n,1
        pwr1 = t**dipprc(i)
        pwr2 = t**dippre(i)
        arg1 = dippra(i) + dipprb(i)/t + dipprd(i)*pwr2
        pression(i) = pwr1*EXP(arg1)
      END DO
    CASE DEFAULT
      WRITE(*, *) 'Wrong choice of model.'
      STOP
    END SELECT
  END SUBROUTINE GETPRESSURE

!  Differentiation of getactivity in forward (tangent) mode:
!   variations   of useful results: activite
!   with respect to varying inputs: temperature concentrations
  SUBROUTINE GETACTIVITY_D(concentrations, concentrationsd, temperature&
&   , temperatured, modelname, modelpars_dim, modelpars, activite, &
&   activited)
    IMPLICIT NONE
    DOUBLE PRECISION, INTENT(IN) :: concentrations(3)
    DOUBLE PRECISION, INTENT(IN) :: concentrationsd(3)
    DOUBLE PRECISION, INTENT(IN) :: temperature
    DOUBLE PRECISION, INTENT(IN) :: temperatured
    CHARACTER(len=20), INTENT(IN) :: modelname
    INTEGER, INTENT(IN) :: modelpars_dim
    DOUBLE PRECISION, INTENT(IN) :: modelpars(modelpars_dim)
    DOUBLE PRECISION, INTENT(OUT) :: activite(3)
    DOUBLE PRECISION, INTENT(OUT) :: activited(3)
! on calcule gamma en fonction du modèle
! attention, la taille du vecteur de paramètres modelpars dépend de modelname
! modelname = 'nrtl', 'wilson', 'uniquac'
! Local variables
    DOUBLE PRECISION, DIMENSION(3, 3) :: a, alpha
    DOUBLE PRECISION, DIMENSION(3) :: rp, q, qp
    DOUBLE PRECISION :: r, z
    INTEGER :: n
    DOUBLE PRECISION :: x(3), t
    DOUBLE PRECISION :: xd(3), td
!! Loop indice
    INTEGER :: i, j, k, m
!! intermediaire variables
    DOUBLE PRECISION, DIMENSION(3) :: partie1, partie2, partie3, partie4&
&   , partie5
    DOUBLE PRECISION, DIMENSION(3) :: partie1d, partie2d, partie3d, &
&   partie4d, partie5d
!! intermediaire variables
    DOUBLE PRECISION, DIMENSION(3, 2) :: fraction1, fraction4
    DOUBLE PRECISION, DIMENSION(3, 2) :: fraction1d, fraction4d
    DOUBLE PRECISION :: fraction2, fraction3, denom1, denom2, denom3, &
&   som1
    DOUBLE PRECISION :: fraction2d, fraction3d, denom1d, denom2d, &
&   denom3d, som1d
    DOUBLE PRECISION, DIMENSION(3, 3) :: tho, g
    DOUBLE PRECISION, DIMENSION(3, 3) :: thod, gd
    DOUBLE PRECISION, DIMENSION(3) :: lnactivite
    DOUBLE PRECISION, DIMENSION(3) :: lnactivited
    DOUBLE PRECISION, DIMENSION(3) :: phi, theta, theta_prim, l
    DOUBLE PRECISION, DIMENSION(3) :: phid, thetad, theta_primd
    INTRINSIC TRIM
    INTRINSIC EXP
    INTRINSIC LOG
    DOUBLE PRECISION :: arg1
    DOUBLE PRECISION :: arg1d
    DOUBLE PRECISION :: temp
    DOUBLE PRECISION :: temp0
    xd = concentrationsd
    x = concentrations
    td = temperatured
    t = temperature
!! Initialisation of the local variables at zero
    partie1 = 0d0
    partie2 = 0d0
    partie3 = 0d0
    partie4 = 0d0
    partie5 = 0d0
    fraction1 = 0d0
    fraction2 = 0d0
    fraction3 = 0d0
    fraction4 = 0d0
    denom1 = 0d0
    denom2 = 0d0
    denom3 = 0d0
    n = 3
!!*****************************************************************************************************************
!!!!!!!!!!!!!!!!!!!!!!!!!!CALCULATION OF ALL PARAMETERS NEEDED TO COSNTRUCT THE EDA SYSTEM!!!!!!!!!!!!!!!!!!!!!!!!!
!!*****************************************************************************************************************
    SELECT CASE  (TRIM(modelname))
    CASE ('NRTL', 'nrtl')
!! nrtl model
! get data
      CALL GETDATAACTIVITY_NRTL(modelname, modelpars_dim, modelpars, a, alpha, r)
      thod = 0.D0
!! Construction of tho(i,j)
      DO i=1,n,1
        DO j=1,n,1
          temp = a(i, j)/(r*(t+273.15))
          thod(i, j) = -(temp*td/(t+273.15))
          tho(i, j) = temp
        END DO
      END DO
      gd = 0.D0
!! Construction of G(i,j)
      DO i=1,n,1
        DO j=1,n,1
          temp = -(alpha(i, j)*tho(i, j))
          gd(i, j) = -(EXP(temp)*alpha(i, j)*thod(i, j))
          g(i, j) = EXP(temp)
        END DO
      END DO
      partie1d = 0.D0
      fraction1d = 0.D0
!! Construction of log's of activities "gamma"
!! Construction of the part 1
      DO i=1,n,1
        DO j=1,n,1
!! Numerator of the de part 1
          temp = tho(j, i)*x(j)
          fraction1d(i, 1) = fraction1d(i, 1) + g(j, i)*(x(j)*thod(j, i)&
&           +tho(j, i)*xd(j)) + temp*gd(j, i)
          fraction1(i, 1) = fraction1(i, 1) + temp*g(j, i)
!! Denumerator of the part 1
          fraction1d(i, 2) = fraction1d(i, 2) + x(j)*gd(j, i) + g(j, i)*&
&           xd(j)
          fraction1(i, 2) = fraction1(i, 2) + g(j, i)*x(j)
        END DO
!!  calculation  of the part 1
        temp = fraction1(i, 1)/fraction1(i, 2)
        partie1d(i) = (fraction1d(i, 1)-temp*fraction1d(i, 2))/fraction1&
&         (i, 2)
        partie1(i) = temp
      END DO
      partie2d = 0.D0
!! Construction of the part 2
      DO i=1,n,1
        DO j=1,n,1
!! the first fraction
          temp = x(j)/fraction1(j, 2)
          fraction2d = temp*gd(i, j) + g(i, j)*(xd(j)-temp*fraction1d(j&
&           , 2))/fraction1(j, 2)
          fraction2 = g(i, j)*temp
!! The second fraction
          fraction3 = 0d0
          fraction3d = 0.D0
          DO m=1,n,1
            temp = x(m)/fraction1(j, 2)
            temp0 = tho(m, j)*g(m, j)
            fraction3d = fraction3d + temp*(g(m, j)*thod(m, j)+tho(m, j)&
&             *gd(m, j)) + temp0*(xd(m)-temp*fraction1d(j, 2))/fraction1&
&             (j, 2)
            fraction3 = fraction3 + temp0*temp
          END DO
!! Calculation of one term of the sommation
          partie2d(i) = partie2d(i) + (tho(i, j)-fraction3)*fraction2d +&
&           fraction2*(thod(i, j)-fraction3d)
          partie2(i) = partie2(i) + fraction2*(tho(i, j)-fraction3)
        END DO
      END DO
      lnactivited = 0.D0
!! Construction of the log's activities by additioning the two parts
      DO i=1,n,1
        lnactivited(i) = partie1d(i) + partie2d(i)
        lnactivite(i) = partie1(i) + partie2(i)
      END DO
      activited = 0.D0
!! Construction de l'activité "gamma"
      DO i=1,n,1
        activited(i) = EXP(lnactivite(i))*lnactivited(i)
        activite(i) = EXP(lnactivite(i))
      END DO
    CASE ('WILSON', 'wilson')
      activited = 0.D0
    CASE ('UNIQUAC', 'uniquac')
! get data
      CALL GETDATAACTIVITY_UNIQUAC(modelname, modelpars_dim, modelpars, &
&                            a, rp, q, qp, z, r)
!! Construction of l(i)
      DO i=1,n,1
        l(i) = z/2*(rp(i)-q(i)) - (rp(i)-1)
      END DO
      denom1d = 0.D0
!! Construction of phi(i)
      DO i=1,n,1
        denom1d = denom1d + rp(i)*xd(i)
        denom1 = denom1 + rp(i)*x(i)
      END DO
      phid = 0.D0
      DO i=1,n,1
        temp0 = x(i)/denom1
        phid(i) = rp(i)*(xd(i)-temp0*denom1d)/denom1
        phi(i) = rp(i)*temp0
      END DO
      denom2d = 0.D0
!! Construction of theta(i)
      DO i=1,n,1
        denom2d = denom2d + q(i)*xd(i)
        denom2 = denom2 + q(i)*x(i)
      END DO
      thetad = 0.D0
      DO i=1,n,1
        temp0 = x(i)/denom2
        thetad(i) = q(i)*(xd(i)-temp0*denom2d)/denom2
        theta(i) = q(i)*temp0
      END DO
      denom3d = 0.D0
!! Construction of theta_prim(i)
      DO i=1,n,1
        denom3d = denom3d + qp(i)*xd(i)
        denom3 = denom3 + qp(i)*x(i)
      END DO
      theta_primd = 0.D0
      DO i=1,n,1
        temp0 = x(i)/denom3
        theta_primd(i) = qp(i)*(xd(i)-temp0*denom3d)/denom3
        theta_prim(i) = qp(i)*temp0
      END DO
      thod = 0.D0
!! Construction of tho(i,j) et tho(j, i)
      DO i=1,n,1
        DO j=1,n,1
          temp0 = a(i, j)/(r*t)
          thod(i, j) = EXP(-temp0)*temp0*td/t
          tho(i, j) = EXP(-temp0)
        END DO
      END DO
      partie1d = 0.D0
!! Construction de la partie 1
      DO i=1,n,1
        temp0 = phi(i)/x(i)
        partie1d(i) = (phid(i)-temp0*xd(i))/(temp0*x(i))
        partie1(i) = LOG(temp0)
      END DO
      partie2d = 0.D0
!! Construction de la partie 2
      DO i=1,n,1
        temp0 = theta(i)/phi(i)
        arg1d = (thetad(i)-temp0*phid(i))/phi(i)
        arg1 = temp0
        partie2d(i) = z*q(i)*arg1d/(2*arg1)
        partie2(i) = z/2*q(i)*LOG(arg1)
      END DO
      som1d = 0.D0
!! Construction de la partie 3
      DO i=1,n,1
        som1d = som1d + l(i)*xd(i)
        som1 = som1 + x(i)*l(i)
      END DO
      partie3d = 0.D0
      DO i=1,n,1
        temp0 = phi(i)*som1/x(i)
        partie3d(i) = -((som1*phid(i)+phi(i)*som1d-temp0*xd(i))/x(i))
        partie3(i) = l(i) - temp0
      END DO
      partie4d = 0.D0
      fraction1d = 0.D0
!! Construction de la partie 4
      DO i=1,n,1
        DO j=1,n,1
          fraction1d(i, 1) = fraction1d(i, 1) + tho(j, i)*theta_primd(j)&
&           + theta_prim(j)*thod(j, i)
          fraction1(i, 1) = fraction1(i, 1) + theta_prim(j)*tho(j, i)
        END DO
        partie4d(i) = -(qp(i)*fraction1d(i, 1)/fraction1(i, 1))
        partie4(i) = -(qp(i)*LOG(fraction1(i, 1)))
      END DO
      partie5d = 0.D0
      fraction4d = 0.D0
!! Construction de la partie 5
      DO i=1,n,1
        DO j=1,n,1
!! the fraction
          temp0 = theta_prim(j)/fraction1(j, 1)
          fraction4d(i, 1) = fraction4d(i, 1) + temp0*thod(i, j) + tho(i&
&           , j)*(theta_primd(j)-temp0*fraction1d(j, 1))/fraction1(j, 1)
          fraction4(i, 1) = fraction4(i, 1) + tho(i, j)*temp0
        END DO
        partie5d(i) = -(qp(i)*fraction4d(i, 1))
        partie5(i) = qp(i)*(1-fraction4(i, 1))
      END DO
      lnactivited = 0.D0
!! Construction du logarithme de l'activité
      DO i=1,n,1
        lnactivited(i) = partie1d(i) + partie2d(i) + partie3d(i) + &
&         partie4d(i) + partie5d(i)
        lnactivite(i) = partie1(i) + partie2(i) + partie3(i) + partie4(i&
&         ) + partie5(i)
      END DO
      activited = 0.D0
!! Construction de l'activité "gamma"
      DO i=1,n,1
        activited(i) = EXP(lnactivite(i))*lnactivited(i)
        activite(i) = EXP(lnactivite(i))
      END DO
    CASE DEFAULT
      WRITE(*, *) 'Wrong choice of model.'
      STOP
    END SELECT
  END SUBROUTINE GETACTIVITY_D

  SUBROUTINE GETACTIVITY(concentrations, temperature, modelname, &
&   modelpars_dim, modelpars, activite)
    IMPLICIT NONE
    DOUBLE PRECISION, INTENT(IN) :: concentrations(3)
    DOUBLE PRECISION, INTENT(IN) :: temperature
    CHARACTER(len=20), INTENT(IN) :: modelname
    INTEGER, INTENT(IN) :: modelpars_dim
    DOUBLE PRECISION, INTENT(IN) :: modelpars(modelpars_dim)
    DOUBLE PRECISION, INTENT(OUT) :: activite(3)
! on calcule gamma en fonction du modèle
! attention, la taille du vecteur de paramètres modelpars dépend de modelname
! modelname = 'nrtl', 'wilson', 'uniquac'
! Local variables
    DOUBLE PRECISION, DIMENSION(3, 3) :: a, alpha
    DOUBLE PRECISION, DIMENSION(3) :: rp, q, qp
    DOUBLE PRECISION :: r, z
    INTEGER :: n
    DOUBLE PRECISION :: x(3), t
!! Loop indice
    INTEGER :: i, j, k, m
!! intermediaire variables
    DOUBLE PRECISION, DIMENSION(3) :: partie1, partie2, partie3, partie4&
&   , partie5
!! intermediaire variables
    DOUBLE PRECISION, DIMENSION(3, 2) :: fraction1, fraction4
    DOUBLE PRECISION :: fraction2, fraction3, denom1, denom2, denom3, &
&   som1
    DOUBLE PRECISION, DIMENSION(3, 3) :: tho, g
    DOUBLE PRECISION, DIMENSION(3) :: lnactivite
    DOUBLE PRECISION, DIMENSION(3) :: phi, theta, theta_prim, l
    INTRINSIC TRIM
    INTRINSIC EXP
    INTRINSIC LOG
    DOUBLE PRECISION :: arg1
    x = concentrations
    t = temperature
!! Initialisation of the local variables at zero
    partie1 = 0d0
    partie2 = 0d0
    partie3 = 0d0
    partie4 = 0d0
    partie5 = 0d0
    fraction1 = 0d0
    fraction2 = 0d0
    fraction3 = 0d0
    fraction4 = 0d0
    denom1 = 0d0
    denom2 = 0d0
    denom3 = 0d0
    n = 3
!!*****************************************************************************************************************
!!!!!!!!!!!!!!!!!!!!!!!!!!CALCULATION OF ALL PARAMETERS NEEDED TO COSNTRUCT THE EDA SYSTEM!!!!!!!!!!!!!!!!!!!!!!!!!
!!*****************************************************************************************************************
    SELECT CASE  (TRIM(modelname))
    CASE ('NRTL', 'nrtl')
!! nrtl model
! get data
      CALL GETDATAACTIVITY_NRTL(modelname, modelpars_dim, modelpars, a, &
&                         alpha, r)
!! Construction of tho(i,j)
      DO i=1,n,1
        DO j=1,n,1
          tho(i, j) = a(i, j)/(r*(t+273.15))
        END DO
      END DO
!! Construction of G(i,j)
      DO i=1,n,1
        DO j=1,n,1
          g(i, j) = EXP(-(alpha(i, j)*tho(i, j)))
        END DO
      END DO
!! Construction of log's of activities "gamma"
!! Construction of the part 1
      DO i=1,n,1
        DO j=1,n,1
!! Numerator of the de part 1
          fraction1(i, 1) = fraction1(i, 1) + tho(j, i)*g(j, i)*x(j)
!! Denumerator of the part 1
          fraction1(i, 2) = fraction1(i, 2) + g(j, i)*x(j)
        END DO
!!  calculation  of the part 1
        partie1(i) = fraction1(i, 1)/fraction1(i, 2)
      END DO
!! Construction of the part 2
      DO i=1,n,1
        DO j=1,n,1
!! the first fraction
          fraction2 = x(j)*g(i, j)/fraction1(j, 2)
!! The second fraction
          fraction3 = 0d0
          DO m=1,n,1
            fraction3 = fraction3 + x(m)*tho(m, j)*g(m, j)/fraction1(j, &
&             2)
          END DO
!! Calculation of one term of the sommation
          partie2(i) = partie2(i) + fraction2*(tho(i, j)-fraction3)
        END DO
      END DO
!! Construction of the log's activities by additioning the two parts
      DO i=1,n,1
        lnactivite(i) = partie1(i) + partie2(i)
      END DO
!! Construction de l'activité "gamma"
      DO i=1,n,1
        activite(i) = EXP(lnactivite(i))
      END DO
    CASE ('WILSON', 'wilson')

    CASE ('UNIQUAC', 'uniquac')
! get data
      CALL GETDATAACTIVITY_UNIQUAC(modelname, modelpars_dim, modelpars, &
&                            a, rp, q, qp, z, r)
!! Construction of l(i)
      DO i=1,n,1
        l(i) = z/2*(rp(i)-q(i)) - (rp(i)-1)
      END DO
!! Construction of phi(i)
      DO i=1,n,1
        denom1 = denom1 + rp(i)*x(i)
      END DO
      DO i=1,n,1
        phi(i) = rp(i)*x(i)/denom1
      END DO
!! Construction of theta(i)
      DO i=1,n,1
        denom2 = denom2 + q(i)*x(i)
      END DO
      DO i=1,n,1
        theta(i) = q(i)*x(i)/denom2
      END DO
!! Construction of theta_prim(i)
      DO i=1,n,1
        denom3 = denom3 + qp(i)*x(i)
      END DO
      DO i=1,n,1
        theta_prim(i) = qp(i)*x(i)/denom3
      END DO
!! Construction of tho(i,j) et tho(j, i)
      DO i=1,n,1
        DO j=1,n,1
          tho(i, j) = EXP(-(a(i, j)/(t*r)))
        END DO
      END DO
!! Construction de la partie 1
      DO i=1,n,1
        partie1(i) = LOG(phi(i)/x(i))
      END DO
!! Construction de la partie 2
      DO i=1,n,1
        arg1 = theta(i)/phi(i)
        partie2(i) = z/2*q(i)*LOG(arg1)
      END DO
!! Construction de la partie 3
      DO i=1,n,1
        som1 = som1 + x(i)*l(i)
      END DO
      DO i=1,n,1
        partie3(i) = l(i) - phi(i)/x(i)*som1
      END DO
!! Construction de la partie 4
      DO i=1,n,1
        DO j=1,n,1
          fraction1(i, 1) = fraction1(i, 1) + theta_prim(j)*tho(j, i)
        END DO
        partie4(i) = -(qp(i)*LOG(fraction1(i, 1)))
      END DO
!! Construction de la partie 5
      DO i=1,n,1
        DO j=1,n,1
!! the fraction
          fraction4(i, 1) = fraction4(i, 1) + theta_prim(j)*tho(i, j)/&
&           fraction1(j, 1)
        END DO
        partie5(i) = qp(i)*(1-fraction4(i, 1))
      END DO
!! Construction du logarithme de l'activité
      DO i=1,n,1
        lnactivite(i) = partie1(i) + partie2(i) + partie3(i) + partie4(i&
&         ) + partie5(i)
      END DO
!! Construction de l'activité "gamma"
      DO i=1,n,1
        activite(i) = EXP(lnactivite(i))
      END DO
    CASE DEFAULT
      WRITE(*, *) 'Wrong choice of model.'
      STOP
    END SELECT
  END SUBROUTINE GETACTIVITY

!  Differentiation of getk in forward (tangent) mode:
!   variations   of useful results: k
!   with respect to varying inputs: temperature concentrations
  SUBROUTINE GETK_D(concentrations, concentrationsd, temperature, &
&   temperatured, modelname_p, modelpars_p_dim, modelpars_p, modelname_g&
&   , modelpars_g_dim, modelpars_g, p0, k, kd)
    IMPLICIT NONE
    DOUBLE PRECISION, DIMENSION(3), INTENT(IN) :: concentrations
    DOUBLE PRECISION, DIMENSION(3), INTENT(IN) :: concentrationsd
    DOUBLE PRECISION, INTENT(IN) :: temperature
    DOUBLE PRECISION, INTENT(IN) :: temperatured
    CHARACTER(len=20), INTENT(IN) :: modelname_p, modelname_g
    INTEGER, INTENT(IN) :: modelpars_p_dim, modelpars_g_dim
    DOUBLE PRECISION, INTENT(IN) :: modelpars_p(modelpars_p_dim), &
&   modelpars_g(modelpars_g_dim)
    INTEGER, INTENT(IN) :: p0
    DOUBLE PRECISION, INTENT(OUT) :: k(3)
    DOUBLE PRECISION, INTENT(OUT) :: kd(3)
!! Local variables
    DOUBLE PRECISION, DIMENSION(3) :: pression, activite
    DOUBLE PRECISION, DIMENSION(3) :: pressiond, activited
    INTEGER :: n
!! Loop indice
    INTEGER :: i
    DOUBLE PRECISION :: temp
    n = 3
    CALL GETPRESSURE_D(temperature, temperatured, modelname_p, &
&                modelpars_p_dim, modelpars_p, pression, pressiond)
    CALL GETACTIVITY_D(concentrations, concentrationsd, temperature, &
&                temperatured, modelname_g, modelpars_g_dim, modelpars_g&
&                , activite, activited)
    kd = 0.D0
    DO i=1,n,1
      temp = pression(i)/p0
      kd(i) = activite(i)*pressiond(i)/p0 + temp*activited(i)
      k(i) = temp*activite(i)
    END DO
  END SUBROUTINE GETK_D

  SUBROUTINE GETK(concentrations, temperature, modelname_p, &
&   modelpars_p_dim, modelpars_p, modelname_g, modelpars_g_dim, &
&   modelpars_g, p0, k)
    IMPLICIT NONE
    DOUBLE PRECISION, DIMENSION(3), INTENT(IN) :: concentrations
    DOUBLE PRECISION, INTENT(IN) :: temperature
    CHARACTER(len=20), INTENT(IN) :: modelname_p, modelname_g
    INTEGER, INTENT(IN) :: modelpars_p_dim, modelpars_g_dim
    DOUBLE PRECISION, INTENT(IN) :: modelpars_p(modelpars_p_dim), &
&   modelpars_g(modelpars_g_dim)
    INTEGER, INTENT(IN) :: p0
    DOUBLE PRECISION, INTENT(OUT) :: k(3)
!! Local variables
    DOUBLE PRECISION, DIMENSION(3) :: pression, activite
    INTEGER :: n
!! Loop indice
    INTEGER :: i
    n = 3
    CALL GETPRESSURE(temperature, modelname_p, modelpars_p_dim, &
&              modelpars_p, pression)
    CALL GETACTIVITY(concentrations, temperature, modelname_g, &
&              modelpars_g_dim, modelpars_g, activite)
    DO i=1,n,1
      k(i) = pression(i)*activite(i)/p0
    END DO
  END SUBROUTINE GETK

END MODULE MODELS_DIFF
